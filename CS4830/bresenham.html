<HTML>
<meta charset="utf-8"/>
<head></head>

<body>

<canvas id="canvas" width="500" height="500" style="border: 1px solid black"></canvas>

<script>

var canvas = document.getElementById("canvas");
var context = canvas.getContext("2d");

canvas.addEventListener("mousedown", handleMouseDown);
canvas.addEventListener("mousemove", handleMouseMove);
canvas.addEventListener("mouseup", handleMouseUp);

  
var p0 = {x: 0, y:0};
var p1 = {x: 0, y:0};

 
var isdown = 0;

 
display();


function setPixel(x, y) {
	context.fillRect(x, y, 1, 1);
}
  

function handleMouseUp(event)
{
	isdown = 0;
	p1.x = event.clientX - canvas.offsetLeft;
	p1.y = event.clientY - canvas.offsetTop;
	display();
}

  

function handleMouseDown(event)
{
	isdown = 1;
	p0.x = event.clientX - canvas.offsetLeft;
	p0.y = event.clientY - canvas.offsetTop;
	display();

}

  

function handleMouseMove(event)

{
	if (isdown == 0)
		return;
	
  	p1.x = event.clientX - canvas.offsetLeft;
	p1.y = event.clientY - canvas.offsetTop;

	display();
}



function bresenham(p0, p1)
{
	//determine octant
	//later, will translate octant
	//don't forget that the coordinate system in the html canvas is flipped
	//determine first point 
	//calculate error using coordinates of first point 
	//impose condition on error in order to determine next point
		//calculate error: D = 2*(y1-y0) - (x1-x0)
		//if D > 0, increase x by one, x++ and leave y the same ~~[y now falls below the true line]~~
		//if D < 0, increase x by one, x++ and increase y, (y++???) ~~[y now resides above or on the true line]~~
	//start at begining coordinate, where the user clicks, mouseDown coords
	//stop at the ending coordingates, where the user lets go of the mouse, !mouseDown coordinates
	




	//grab start and end coordinates
	//determine octant information (why?? why do we care what octant we are in..? i guess this will become more apparent later...)
	//begin iterating. 
		//for i in range start coords to end coords
			//calculate D
			//D = 2(change in y) - (change in x)
			//D = 2(next y - current y) - (next x - current x)
			// how can we know what the next value of y is if 
				//that relies on what the value of D is???? 

			// so it seems like there is some initial value to set y equal to 
	
				//or something is getting lost along the way.. in my brain. lol 

			//calculate D = 2(next y - current y) - (next x - current x)
			//use value of D to determine next value of y
			//if (D > 0) leave y the same
			//if (D < 0) increase y

				//these conditions might be reversed, need to check with the assignment to be sure. 


			//five values, 
			//var current_x
			//var next_x
			//var current_y 
			//var next_y
			//var d_error


			//always increase x by one
			//y will never decrement, but it could increment by a negative number? using += depending on octant??? 
								///scratch that, this is for later, will be doing everything in first octannt
								//where everthing is posistive, then will translate coords??? 
						//need to decide at some point when to do the transformation. . . .   



			
//also, there is some confusion about current and next values, 
//make sure that the naming convention represents dx and dy in a way that makes sense
//for example, you have to update y-current and x-current in every loop in such a way that 
//there is a new current and current current... oh my lol we can work this out in a way that's non ambiguous.. 


	//grab start coords, x0, y0 --> mouse click
	//grab end coords, x1, y1   --> mouse release
	//start iterating to calculate error from start point to end point
		//x_current , x_next , y_current , y_next , D
		//init x_current will be x0
		//init x_next will be x_current + 1
		//init y_current will be y0
		//init y_next will be          ??????     depends on value of D? or .. assume value for y_next on first round..? 
		//init D will be               ??????     depends on value of y? or .. assume value for D      on first round..?
		//NOTE: need updated values for D calculateion... the update is crucial here... ? 
		//calculate D = 2(y_next - y_current) - (x_next - x_current)
		//if(D < 0) y_current++, [[i think there might not need to be a y next... let's see . .  .]]
		//if(D > 0) y_current = y_current
		//always increase x_current by one, x_current++
		





		//so, now we have our coordinates. with our newly calculated coordinates based on D, 
			//our pixel at (curent_x, current_y) can be filled in
			//fillPixel(x_current, y_current)

		//move on to the next iteration




//some issues: 
	//initializing y_current and D for the first iteration
	//should there be a y_next involved in the calculation
	//edge cases like moving outside of the canvas, 
		//lines on the abscissa and ordinate
		//lines with little to no length
		//translating to octants
		//defining octant boundaries


	var x_start = p0[0];
	var y_start = p0[1];
	var x_end = p1[0];
	var y_end = p1[1];
	var y_current = y_start;
	for(var x_current = x_start; x_current <= x_end; x_current++) {
		boolean inhere = false;
		var x_next = x_current + 1;
		//y_current depends on D
		var D;//depends on y...?
		var y_next;
		if((x_current == x_start) && (y_current == y_start)) {
			setPixel(x_current, y_current);
			//   ....  other document coloring stuff ...
			inhere = true;
		}
		if(x_current == x_start && !inhere) {
			y_next = y_current + 1; //let's start by initializing y_current to increasing..? 
		} else {
			y_next = y_current;
		}
		D = 2*(y_next - y_current) - (x_next - x_current);
		if(D < 0) {
			y_current++;	
		}
		setPixel(x_next, y_next);
	} 











}

  

function display()
{
	context.clearRect(0, 0, canvas.width, canvas.height);
	var dx = p1.x - p0.x;
	var dy = p1.y - p0.y;

	context.fillStyle = "#000000";
	context.strokeStyle = "#000000";
	
	//bresenham(p0, p1); <!-- this should work before you turn in your assignment -->


	// this is what your algorithm SHOULD output, comment these when working on the algorithm
	context.beginPath();
	context.moveTo(p0.x, p0.y);
	context.lineTo(p1.x, p1.y);
	context.stroke();

}

  

</script>

<p id='quadrant'></p>

</body>

</html>
