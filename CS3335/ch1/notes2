its a pointer pointing to what?? 


its a pointer pointing to a double. 
this is very important

its a pointer of double 


remember that memory is stored in a tabular arrangement


*p de-reference 
take the address of d  -->   &d
its some big number that us as humans don't have control over 


lets run the program and take a look.. 

double *p

	make a pointer of type double

p = &d
	assign the numerical value of d's address to the 
	pointer p
	p is a pointer of type double 



the address of d is just a number
like the address of a house is just a numver

but you can use that number as an address which will
lead you to the right place... 

make room for this special addres number.

	double pointer p
and put that number in the special pointer space

normally, p is just chilling, hanging out
	holding the stupid number which is d's address 

but.. we can d-reference p, the pointer
	and use it to get to d

we just use p to get to d 


... so we really don't care about p. 

but if we really cared about p, 

we can grab information aboutj p 

	we can grab the size of p -- 
	we can grab the address of p -- 

but we don't really care.. 

we just use p to point to d.. 

(but i think we can make pointers point to p.. )
	then we might care about p 


*p use the value stored in p as an address 

	*p stop caring about p and use the value 
	at p and grab the value at the address 





we don't care about the physicl address of a piece of data.. 
it's irrelevant to the logic of our program 
and chances are that it changes







it's th value that p is pointing to that gets updated!!! 
	not the value in p itself
	yes p holds a value
	its a number 
	and it has value.. 
	AND WE CAN CHANGE THE VALUE OF p 
	BUT!! we can 
		de-reference p   -- >  *p

		and make changes to d!! 
		
		so do this
		*p += 20

		this does the following: 

			use the value at p as an address
			follow the address to the data at 
				that address in memeory
			update (incrememnt) that value in memeory 



c00ll 



[pointer notes]

[1.]  do not assume that a pointer points anywhere useful until you
	explictly assign it to something

DO NOT ASSUME THE VALUES OF POINTERS


[2.]  also, 

	one pointer an be assigend to another if they are the
		same type
	OR
	one of the pointers is of the type void



*(?)how can a data type be assigend teh value void?? 
	is that different than null/nill(?)*



you can type cast pointers

nothing stops pointers from pointing to an invalid address

c assumes that the programmer knows what he or she is doing

if you break something, it is your resp. to fix/address/prep


{{DANGER}}


dont do this: 

double *p;
p = 1234


you are assigning an actual value to p
	you are not addressing 


you are breaking other peoples stuff
what if this belongs to the OS!!
you might break someone else's system/prgram
you might crash your whole system!!! 

c is low . . . it works directly with hardware and memory 

it assumes you won't do this

but don't assign numerical values to pointers. 


DE-REF the pointers and just use them as pass throught to
	other vairables....




~~~~~~




don't adjust your pointers beyond the boundaries of the array
	`the compiler won't catch it 
	`segmentation fault or core dump
	`the os has decided to kill your program 	
		(because danger)
	`don't de-allocate storage that other pointers still reference
	`there is a heap 
	`there is a call stack
	`heap is a piece of memory that dynamically allows you 
		to allocate and de-allocate memory 
	`heap asks OS and you mess with the heap
	`you use it, then you give it back

	`you only want to play with your own stuff...heap
		you are the owner of the pointers and teh 
		data that you mess around with in program
		so don't mess around with other memory.. 	
		..but there is no mechanism to stop you!! '
		so be careful 
	`use memory and put it back in the pool 
	`for everyone to use when you are done


those are some common mistakes that people make with pointers 
	that are dangerous and break stuff.. 



lets look at 
southeast.c





.....









